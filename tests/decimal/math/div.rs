use rstest::*;

use fastnum::{
    dec128, dec256, dec512,
    decimal::{
        ArithmeticError, ArithmeticPolicy, OverflowPolicy, RoundingMode, RoundingMode::*,
        RoundingPolicy,
    },
    D128, D256, D512,
};

use crate::decimal::common::math::div::test_impl;

test_impl!(D, 128);
test_impl!(D, 256);
test_impl!(D, 512);

test_impl!(UD, 128);
test_impl!(UD, 256);
test_impl!(UD, 512);

#[rstest(::trace)]
#[case(dec128!(1), dec128!(3), dec128!(0.333333333333333333333333333333333333333), HalfUp)]
#[case(dec128!(1), dec128!(3), dec128!(0.333333333333333333333333333333333333333), Down)]
#[case(dec128!(1), dec128!(3), dec128!(0.333333333333333333333333333333333333334), Up)]
#[case(dec128!(2), dec128!(3), dec128!(0.66666666666666666666666666666666666667), HalfUp)]
#[case(dec128!(2), dec128!(3), dec128!(0.66666666666666666666666666666666666666), Down)]
#[case(dec128!(2), dec128!(3), dec128!(0.66666666666666666666666666666666666667), Up)]
#[case(dec128!(8), dec128!(9), dec128!(0.88888888888888888888888888888888888889), HalfUp)]
#[case(dec128!(8), dec128!(9), dec128!(0.88888888888888888888888888888888888888), Down)]
fn test_div_inexact(
    #[case] a: D128,
    #[case] b: D128,
    #[case] expected: D128,
    #[case] mode: RoundingMode,
) {
    let res = a.div(b, mode).unwrap();

    assert_eq!(res, expected);
    assert_eq!(
        res.fractional_digits_count(),
        expected.fractional_digits_count()
    );

    let policy = ArithmeticPolicy::new(OverflowPolicy::Strict, RoundingPolicy::Strict);

    let res = a.div(b, mode);
    assert_eq!(
        res.ok_or_err_with_policy(&policy).unwrap_err(),
        ArithmeticError::Inexact
    );
}

#[rstest(::trace)]
#[case(dec256!(1), dec256!(3), dec256!(0.33333333333333333333333333333333333333333333333333333333333333333333333333333), HalfUp)]
#[case(dec256!(1), dec256!(3), dec256!(0.33333333333333333333333333333333333333333333333333333333333333333333333333333), Down)]
#[case(dec256!(1), dec256!(3), dec256!(0.33333333333333333333333333333333333333333333333333333333333333333333333333334), Up)]
#[case(dec256!(2), dec256!(3), dec256!(0.66666666666666666666666666666666666666666666666666666666666666666666666666667), HalfUp)]
#[case(dec256!(2), dec256!(3), dec256!(0.66666666666666666666666666666666666666666666666666666666666666666666666666666), Down)]
#[case(dec256!(2), dec256!(3), dec256!(0.66666666666666666666666666666666666666666666666666666666666666666666666666667), Up)]
#[case(dec256!(8), dec256!(9), dec256!(0.88888888888888888888888888888888888888888888888888888888888888888888888888889), HalfUp)]
#[case(dec256!(8), dec256!(9), dec256!(0.88888888888888888888888888888888888888888888888888888888888888888888888888888), Down)]
#[case(dec256!(12.34), dec256!(1.233), dec256!(10.0081103000811030008110300081103000811030008110300081103000811030008110300081), HalfUp)]
#[case(dec256!(125348), dec256!(352.2283), dec256!(355.87146177635357522379661145910195177389210350218877926617480764606364678818), HalfUp)]
fn test_div_inexact_256(
    #[case] a: D256,
    #[case] b: D256,
    #[case] expected: D256,
    #[case] mode: RoundingMode,
) {
    let res = a.div(b, mode).unwrap();

    assert_eq!(res, expected);
    assert_eq!(
        res.fractional_digits_count(),
        expected.fractional_digits_count()
    );

    let policy = ArithmeticPolicy::new(OverflowPolicy::Strict, RoundingPolicy::Strict);

    let res = a.div(b, mode);
    assert_eq!(
        res.ok_or_err_with_policy(&policy).unwrap_err(),
        ArithmeticError::Inexact
    );
}

#[rstest(::trace)]
#[case(dec512!(1), dec512!(3), dec512!(0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333), HalfUp)]
#[case(dec512!(1), dec512!(3), dec512!(0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333), Down)]
#[case(dec512!(1), dec512!(3), dec512!(0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333334), Up)]
#[case(dec512!(2), dec512!(3), dec512!(0.6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666667), HalfUp)]
#[case(dec512!(2), dec512!(3), dec512!(0.6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666), Down)]
#[case(dec512!(2), dec512!(3), dec512!(0.6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666667), Up)]
#[case(dec512!(8), dec512!(9), dec512!(0.8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888889), HalfUp)]
#[case(dec512!(8), dec512!(9), dec512!(0.8888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888), Down)]
#[case(dec512!(12.34), dec512!(1.233), dec512!(10.008110300081103000811030008110300081103000811030008110300081103000811030008110300081103000811030008110300081103000811030008110300081103000811030008110300), HalfUp)]
#[case(dec512!(125348), dec512!(352.2283), dec512!(355.8714617763535752237966114591019517738921035021887792661748076460636467881768727839301952739175131583691600021917602872909416988924512879856615723381682), HalfUp)]
fn test_div_inexact_512(
    #[case] a: D512,
    #[case] b: D512,
    #[case] expected: D512,
    #[case] mode: RoundingMode,
) {
    let res = a.div(b, mode).unwrap();

    assert_eq!(res, expected);
    assert_eq!(
        res.fractional_digits_count(),
        expected.fractional_digits_count()
    );

    let policy = ArithmeticPolicy::new(OverflowPolicy::Strict, RoundingPolicy::Strict);

    let res = a.div(b, mode);
    assert_eq!(
        res.ok_or_err_with_policy(&policy).unwrap_err(),
        ArithmeticError::Inexact
    );
}
